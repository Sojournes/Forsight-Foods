import streamlit as st
import pandas as pd
import google.generativeai as genai
import json
from io import StringIO
import os

# --- Configuration ---
APP_TITLE = "Foresight Foods: AI-Powered Kitchen"

# Call st.set_page_config() as the VERY FIRST Streamlit command
st.set_page_config(page_title=APP_TITLE, layout="wide")

api_key_load_messages = []  # Store messages to display after set_page_config
GEMINI_API_KEY = st.sidebar.text_input(
    "Enter Gemini API Key",
    type="password",
    help="Paste your Gemini API Key here to enable AI features."
)

model = None  # Initialize model to None

# Configure Gemini only if key is provided
if GEMINI_API_KEY:
    genai.configure(api_key=GEMINI_API_KEY)
    model = genai.GenerativeModel('gemini-1.5-flash')
    api_key_load_messages.append(("sidebar_success", "Gemini API Key loaded successfully!"))

# Display API key loading messages now that set_page_config has run
for msg_type, msg_content in api_key_load_messages:
    if msg_type == "info":
        st.info(msg_content)
    elif msg_type == "warning":
        st.warning(msg_content)
    elif msg_type == "sidebar_success":
        st.sidebar.success(msg_content)
    elif msg_type == "sidebar_warning":
        st.sidebar.warning(msg_content)

# --- Helper Functions ---

def generate_with_gemini(prompt_text, expect_json=False):
    """
    Generates content using the Gemini model.
    Args:
        prompt_text (str): The prompt to send to the model.
        expect_json (bool): If True, will try to parse the output as JSON.
    Returns:
        str or dict: The generated text or parsed JSON object.
    """
    if not model:
        st.warning("Gemini API key not configured or model not initialized. AI generation is disabled.")
        return "AI generation disabled. Please configure API key and ensure the model is initialized."

    try:
        st.info("Generating response from AI... Please wait.")
        mime_type = "application/json" if expect_json else "text/plain"
        generation_config = genai.types.GenerationConfig(
            temperature=0.2,
            response_mime_type=mime_type
        )
        response = model.generate_content(prompt_text, generation_config=generation_config)

        if response.candidates:
            content = response.candidates[0].content.parts[0].text
            if expect_json:
                try:
                    cleaned_content = content.strip()
                    if cleaned_content.startswith("```json"):
                        cleaned_content = cleaned_content[7:-3].strip()
                    elif cleaned_content.startswith("```"):
                        cleaned_content = cleaned_content[3:-3].strip()
                    return json.loads(cleaned_content)
                except json.JSONDecodeError as e:
                    st.error(f"Failed to parse JSON response from AI: {e}")
                    st.text_area("Raw AI Response (JSON parsing failed):", content, height=200)
                    return {"error": "Failed to parse JSON", "raw_response": content}
            return content
        else:
            st.error("No content generated by AI.")
            if response.prompt_feedback:
                st.warning(f"Prompt feedback: {response.prompt_feedback}")
            return "Error: No content generated."
    except Exception as e:
        st.error(f"An error occurred during AI generation: {e}")
        return f"Error: {e}"

# --- Page Implementations ---

def dashboard_page():
    """Renders the Dashboard page."""
    st.title("Dashboard")
    st.header("Real-time overview of food service operations.")

    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("Today's Food Consumption", "1,234 units", "+5% from yesterday")
    with col2:
        st.metric("Today's Food Waste", "87 units", "-2% from yesterday")
    with col3:
        st.metric("Predicted Demand (Next 24h)", "~1,500 units", "Stable")

    st.subheader("Food Consumption Trend (Last 7 days)")
    consumption_data = pd.DataFrame({
        'Day': ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
        'Units': [180, 190, 200, 210, 220, 205, 195]
    })
    st.bar_chart(consumption_data.set_index('Day'))

    st.subheader("Food Waste Trend (Last 7 days)")
    waste_data = pd.DataFrame({
        'Day': ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
        'Units': [40, 35, 30, 25, 20, 22, 28]
    })
    st.bar_chart(waste_data.set_index('Day'))

    st.markdown("---")
    st.header("AI-Powered Demand Forecasting")
    st.write("""
    Get smart predictions for your kitchen.
    Leverage historical data, event schedules, weather patterns, and local events
    to accurately forecast food demand. Minimize waste and optimize preparation
    with AI-driven insights.
    """)
    if st.button("Go to Demand Forecaster"):
        st.session_state.current_page = "Demand Forecaster"
        st.rerun() 

def demand_forecaster_page():
    """Renders the Demand Forecaster page."""
    st.title("Demand Forecaster")
    st.write("Predict food demand using AI based on various factors.")

    with st.expander("Input Data for Forecasting", expanded=True):
        st.write("Provide the necessary information for the AI to generate a demand forecast.")

        historical_data_json_str = st.text_area(
            "Historical Consumption Data (JSON)",
            height=150,
            placeholder='e.g., [{"date": "2024-05-20", "item": "Caesar Salad", "sold": 50}, ...]',
            help="Paste JSON data of past sales, daily consumption quantities of items."
        )
        event_schedules_text = st.text_area(
            "Event Schedules & Audience Profiles",
            height=100,
            placeholder="e.g., Upcoming conferences, sports events, expected attendance numbers and types..."
        )
        weather_forecast_text = st.text_area(
            "Weather Forecast",
            height=68,
            placeholder="e.g., Next 7 days: Sunny, average 25Â°C. Weekend: Possible rain..."
        )
        local_events_text = st.text_area(
            "Local Events Impacting Demand",
            height=68,
            placeholder="e.g., Local festival next week, school holidays, nearby office closures..."
        )

    if st.button("Generate Forecast", type="primary"):
        if not GEMINI_API_KEY:
            st.error("Gemini API Key not configured. Please set it in Streamlit secrets or a .env file.")
            return
        if not model:
            st.error("Gemini model not initialized. Please check API key configuration.")
            return

        if not historical_data_json_str:
            st.warning("Please provide historical consumption data.")
            return

        try:
            json.loads(historical_data_json_str)
        except json.JSONDecodeError:
            st.error("Historical Consumption Data is not valid JSON. Please check the format.")
            return

        prompt = f"""
        You are an AI assistant for a kitchen, tasked with forecasting food demand.
        Given the following information:
        Historical Consumption Data (JSON string):
        ```json
        {historical_data_json_str}
        ```
        Event Schedules & Audience Profiles:
        {event_schedules_text if event_schedules_text else "Not provided"}

        Weather Forecast:
        {weather_forecast_text if weather_forecast_text else "Not provided"}

        Local Events Impacting Demand:
        {local_events_text if local_events_text else "Not provided"}

        Please provide a demand forecast for the next 24 hours.
        The forecast should be itemized if possible, considering the provided historical data patterns and other factors.
        Respond ONLY with a valid JSON object (no markdown formatting like ```json ... ```) with the following schema:
        {{
          "overall_prediction": {{
            "units": "integer",
            "trend_comment": "string (e.g., Stable, Increasing, Decreasing based on inputs)"
          }},
          "itemized_forecast": [
            {{
              "item_name": "string",
              "predicted_units": "integer",
              "reasoning": "string (briefly explain prediction based on inputs, optional)"
            }}
          ],
          "confidence_score": "float (0.0 to 1.0, estimate based on data quality, optional)",
          "suggestions_for_accuracy": [
            "string (e.g., 'Provide more granular historical data for item X', 'Specify audience type for events')"
          ]
        }}
        If itemized forecast is not possible from the provided data, provide a general forecast for total units and explain why in 'suggestions_for_accuracy'.
        Focus on minimizing potential food waste by not over-predicting. Be realistic.
        If specific item names are in historical data, try to forecast for those items.
        If event schedules are provided, consider their impact on specific items if plausible (e.g., conference might increase coffee demand).
        """
        with st.spinner("AI is analyzing data and generating forecast..."):
            forecast_result = generate_with_gemini(prompt, expect_json=True)

        st.subheader("AI Generated Forecast:")
        if isinstance(forecast_result, dict) and "error" not in forecast_result:
            st.json(forecast_result) 
            if "overall_prediction" in forecast_result and isinstance(forecast_result["overall_prediction"], dict) :
                 st.metric("Overall Predicted Units (Next 24h)",
                           forecast_result["overall_prediction"].get("units", "N/A"),
                           forecast_result["overall_prediction"].get("trend_comment", ""))
            if "itemized_forecast" in forecast_result and forecast_result["itemized_forecast"]:
                st.write("Itemized Predictions:")
                try:
                    df_forecast = pd.DataFrame(forecast_result["itemized_forecast"])
                    st.dataframe(df_forecast)
                except Exception as e:
                    st.warning(f"Could not display itemized forecast as a table: {e}")
                    st.write(forecast_result["itemized_forecast"]) 

            if "suggestions_for_accuracy" in forecast_result and forecast_result["suggestions_for_accuracy"]:
                st.info("Suggestions for improving forecast accuracy:")
                for suggestion in forecast_result["suggestions_for_accuracy"]:
                    st.write(f"- {suggestion}")

        elif isinstance(forecast_result, str): 
            st.text_area("Raw AI Response (Non-JSON)", forecast_result, height=300)
        elif isinstance(forecast_result, dict) and "error" in forecast_result: 
             st.error(f"Forecast generation error: {forecast_result['error']}")
             if "raw_response" in forecast_result:
                st.text_area("Raw AI Response (Error):", forecast_result["raw_response"], height=300)
        else:
            st.error("Failed to generate a valid forecast. The response was not in the expected format.")


def waste_minimizer_page():
    """Renders the Waste Minimizer page."""
    st.title("Waste Minimizer")
    st.write("Generate AI-powered food preparation reports to optimize stock and reduce waste.")

    with st.expander("Input Data for Preparation Report", expanded=True):
        st.write("Provide details for the AI to generate an optimized food prep report.")
        predicted_demand_data_str = st.text_area(
            "Predicted Demand (JSON or Text)",
            height=100,
            placeholder='e.g., Output from Demand Forecaster, or {"item": "Burger", "predicted_units": 100}, ...'
        )
        historical_data_json_str = st.text_area(
            "Historical Data (Consumption, Waste, Stock - JSON)",
            height=150,
            placeholder='e.g., [{"date": "2024-05-20", "item": "Salad", "consumed": 45, "wasted": 5, "stock_start": 60, "stock_end": 10}, ...]'
        )
        menu_ingredients_text = st.text_area(
            "Current Menu & Ingredients per Item",
            height=100,
            placeholder="e.g., Caesar Salad: Lettuce, Croutons, Dressing, Chicken. Burger: Bun, Patty, Cheese, Lettuce, Tomato. List ingredients per item."
        )
        seasonality_factors_text = st.text_area(
            "Seasonality Factors",
            height=68,
            placeholder="e.g., Summer fruits availability, winter specials, holiday demand shifts..."
        )

    if st.button("Generate Prep Report", type="primary"):
        if not GEMINI_API_KEY:
            st.error("Gemini API Key not configured. Please set it in Streamlit secrets or a .env file.")
            return
        if not model:
            st.error("Gemini model not initialized. Please check API key configuration.")
            return

        if not predicted_demand_data_str:
            st.warning("Please provide predicted demand data.")
            return

        try:
            if historical_data_json_str.strip(): 
                json.loads(historical_data_json_str)
        except json.JSONDecodeError:
            st.error("Historical Data is not valid JSON. Please check the format or leave empty if not applicable.")
            return
        try:
            if predicted_demand_data_str.strip().startswith("{") or predicted_demand_data_str.strip().startswith("["):
                 json.loads(predicted_demand_data_str)
        except json.JSONDecodeError:
            st.info("Predicted demand is not JSON, treating as plain text for the prompt.")


        prompt = f"""
        You are an AI assistant for a kitchen, tasked with optimizing food preparation to minimize waste.
        Given the following information:

        Predicted Demand (JSON string or Text):
        ```
        {predicted_demand_data_str}
        ```

        Historical Data (Consumption, Waste, Stock - JSON string, optional):
        ```json
        {historical_data_json_str if historical_data_json_str else "Not provided"}
        ```

        Current Menu & Ingredients per Item:
        {menu_ingredients_text if menu_ingredients_text else "Not provided"}

        Seasonality Factors:
        {seasonality_factors_text if seasonality_factors_text else "Not provided"}

        Please generate an optimized food preparation report.
        The report should list menu items and the quantity to prepare for each.
        Consider current stock levels (if provided in historical data) and ingredient availability from the menu.
        The goal is to meet predicted demand while minimizing waste.
        Respond ONLY with a valid JSON object (no markdown formatting like ```json ... ```) with the following schema:
        {{
          "preparation_list": [
            {{
              "menu_item": "string",
              "quantity_to_prepare": "integer",
              "unit": "string (e.g., portions, units, kg)",
              "reasoning_notes": "string (briefly explain prep quantity based on demand, stock, ingredients, optional)"
            }}
          ],
          "waste_reduction_tips": [
            "string (provide 2-3 general tips based on the inputs provided, e.g., 'Utilize shared ingredients across menu items X and Y.')"
          ],
          "missing_info_suggestions": [
            "string (e.g., 'Provide current stock levels for more accurate prep quantities.', 'Specify ingredient quantities per menu item.')"
          ]
        }}
        If menu_ingredients_text is provided, use it to understand what can be made.
        If historical_data_json_str includes stock levels, use them to adjust preparation quantities.
        """
        with st.spinner("AI is analyzing data and generating prep report..."):
            prep_report_result = generate_with_gemini(prompt, expect_json=True)

        st.subheader("AI Generated Preparation Report:")
        if isinstance(prep_report_result, dict) and "error" not in prep_report_result:
            st.json(prep_report_result) 
            if "preparation_list" in prep_report_result and prep_report_result["preparation_list"]:
                st.write("Preparation List:")
                try:
                    df_prep = pd.DataFrame(prep_report_result["preparation_list"])
                    st.dataframe(df_prep)
                except Exception as e:
                    st.warning(f"Could not display preparation list as a table: {e}")
                    st.write(prep_report_result["preparation_list"])

            if "waste_reduction_tips" in prep_report_result and prep_report_result["waste_reduction_tips"]:
                st.info("Waste Reduction Tips:")
                for tip in prep_report_result["waste_reduction_tips"]:
                    st.write(f"- {tip}")
            if "missing_info_suggestions" in prep_report_result and prep_report_result["missing_info_suggestions"]:
                st.warning("Suggestions for better reports:")
                for sug in prep_report_result["missing_info_suggestions"]:
                    st.write(f"- {sug}")
        elif isinstance(prep_report_result, str):
             st.text_area("Raw AI Response (Non-JSON)", prep_report_result, height=300)
        elif isinstance(prep_report_result, dict) and "error" in prep_report_result:
            st.error(f"Prep report generation error: {prep_report_result['error']}")
            if "raw_response" in prep_report_result:
                st.text_area("Raw AI Response (Error):", prep_report_result["raw_response"], height=300)
        else:
            st.error("Failed to generate a valid preparation report. The response was not in the expected format.")


def feedback_loop_page():
    """Renders the Feedback Loop page."""
    st.title("Feedback Loop")
    st.write("Help improve AI accuracy by providing actual usage data.")

    with st.form("feedback_form"):
        st.subheader("Submit Usage Feedback")
        menu_item_name = st.text_input("Menu Item Name", placeholder="e.g., Caesar Salad, Beef Tacos")
        predicted_amount = st.number_input("Predicted Amount (units)", min_value=0, step=1, placeholder="e.g., 50")
        actual_amount_used = st.number_input("Actual Amount Used (units)", min_value=0, step=1, placeholder="e.g., 45")
        notes = st.text_area("Notes (Optional)", placeholder="e.g., Unexpectedly popular, ingredients ran low...")
        submitted = st.form_submit_button("Submit Feedback")

        if submitted:
            if not menu_item_name or predicted_amount is None or actual_amount_used is None : 
                st.warning("Please fill in Menu Item Name, Predicted Amount, and Actual Amount Used.")
            else:
                feedback_data = {
                    "menu_item": menu_item_name,
                    "predicted": predicted_amount,
                    "actual": actual_amount_used,
                    "notes": notes
                }
                if 'feedback_history' not in st.session_state:
                    st.session_state.feedback_history = []
                st.session_state.feedback_history.append(feedback_data)
                st.success("Feedback submitted successfully!")
                st.json(feedback_data) 

    if 'feedback_history' in st.session_state and st.session_state.feedback_history:
        st.subheader("Submitted Feedback History (Current Session Only)")
        try:
            df_feedback = pd.DataFrame(st.session_state.feedback_history)
            st.dataframe(df_feedback)
        except Exception as e:
            st.warning(f"Could not display feedback history as a table: {e}")
            st.write(st.session_state.feedback_history)
        st.caption("This feedback is only stored for the current session. In a real application, this data would be persistently stored and used for model retraining or prompt refinement.")

# --- Main App Logic ---
# Note: st.set_page_config() is now at the top of the script.

if "current_page" not in st.session_state:
    st.session_state.current_page = "Dashboard"

st.sidebar.title("Foresight Foods")
page_options = ["Dashboard", "Demand Forecaster", "Waste Minimizer", "Feedback Loop"]

if st.session_state.current_page not in page_options:
    st.session_state.current_page = "Dashboard"

st.session_state.current_page = st.sidebar.radio(
    "Navigate",
    page_options,
    index=page_options.index(st.session_state.current_page) 
)
st.sidebar.markdown("---")
st.sidebar.info(
    "This app uses Gemini AI for forecasting and reporting. "
    "Ensure your API key is configured."
)
# Sidebar messages for API key status are now handled by the api_key_load_messages loop
# or the st.error if key is critically missing.


# Page Routing
if st.session_state.current_page == "Dashboard":
    dashboard_page()
elif st.session_state.current_page == "Demand Forecaster":
    demand_forecaster_page()
elif st.session_state.current_page == "Waste Minimizer":
    waste_minimizer_page()
elif st.session_state.current_page == "Feedback Loop":
    feedback_loop_page()

